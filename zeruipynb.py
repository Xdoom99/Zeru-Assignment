# -*- coding: utf-8 -*-
"""Zeruipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Gh8cvt6-fYEzX_87dkoNG7qTdtxplBtP
"""

!pip install pandas scikit-learn matplotlib seaborn tqdm

import json
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import MinMaxScaler
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
from tqdm import tqdm

from google.colab import files
uploaded = files.upload()

import zipfile

zip_path = "/content/user-wallet-transactions.json.zip"
extract_path = "/content/aave_data"

with zipfile.ZipFile(zip_path, 'r') as zip_ref:
    zip_ref.extractall(extract_path)

print("âœ… ZIP extracted to:", extract_path)

import json
import os

json_file_path = os.path.join(extract_path, "user-wallet-transactions.json")

with open(json_file_path, 'r') as f:
    raw_data = json.load(f)

print(f"âœ… Loaded {len(raw_data)} transaction records.")

import pprint
pprint.pprint(raw_data[0])

import pandas as pd

df = pd.json_normalize(raw_data)


df['wallet'] = df['userWallet']
df['action'] = df['action']
df['amount_raw'] = df['actionData.amount'].astype(float)
df['price_usd'] = df['actionData.assetPriceUSD'].astype(float)
df['amount_usd'] = df['amount_raw'] * df['price_usd'] / (10**6)

df = df[['wallet', 'action', 'amount_usd', 'timestamp']]

print("âœ… Cleaned DataFrame:")
df.head()

from tqdm import tqdm

wallet_features = []

for wallet, group in tqdm(df.groupby('wallet')):
    actions = group['action'].value_counts().to_dict()

    total_tx = len(group)
    total_amount = group['amount_usd'].sum()
    avg_amount = group['amount_usd'].mean()
    max_amount = group['amount_usd'].max()
    unique_actions = group['action'].nunique()

    wallet_features.append({
        'wallet': wallet,
        'total_tx': total_tx,
        'total_amount_usd': total_amount,
        'avg_amount_usd': avg_amount,
        'max_amount_usd': max_amount,
        'unique_actions': unique_actions,
        'num_liquidations': actions.get('liquidationcall', 0),
        'num_borrows': actions.get('borrow', 0),
        'num_repays': actions.get('repay', 0),
        'num_deposits': actions.get('deposit', 0),
        'num_redemptions': actions.get('redeemunderlying', 0),
    })

features_df = pd.DataFrame(wallet_features)
features_df.fillna(0, inplace=True)

print("âœ… Wallet-level feature DataFrame:")
features_df.head()

from sklearn.preprocessing import MinMaxScaler
import numpy as np


score_features = features_df.drop(columns=['wallet'])

scaler = MinMaxScaler()
scaled = scaler.fit_transform(score_features)


weights = np.array([
    1.0,
    1.2,
    1.0,
    0.8,
    1.0,
   -2.0,
    0.5,
    1.0,
    1.2,
    1.0
])

scores = (scaled @ weights) * 1000

# Clip to 0â€“1000 and add to DataFrame
features_df['credit_score'] = np.clip(scores, 0, 1000).astype(int)

print("âœ… Scored wallets:")
features_df[['wallet', 'credit_score']].head()

features_df[['wallet', 'credit_score']].to_csv("wallet_scores.csv", index=False)

from google.colab import files
files.download("wallet_scores.csv")

import matplotlib.pyplot as plt
import seaborn as sns

features_df['score_bin'] = pd.cut(features_df['credit_score'],
                                   bins=[0,100,200,300,400,500,600,700,800,900,1000],
                                   labels=["0-100", "100-200", "200-300", "300-400", "400-500",
                                           "500-600", "600-700", "700-800", "800-900", "900-1000"])

# Plot
plt.figure(figsize=(10, 6))
sns.countplot(data=features_df, x='score_bin', order=features_df['score_bin'].cat.categories, palette='coolwarm')
plt.title("Credit Score Distribution of Wallets")
plt.xlabel("Score Range")
plt.ylabel("Number of Wallets")
plt.xticks(rotation=45)
plt.grid(axis='y')
plt.tight_layout()
plt.show()

from google.colab import files
uploaded = files.upload()

import pandas as pd

df = pd.read_csv("wallet_scores.csv")

# Bin the scores into ranges of 100
df['score_bin'] = pd.cut(df['credit_score'],
                         bins=[0,100,200,300,400,500,600,700,800,900,1000],
                         labels=["0â€“100", "100â€“200", "200â€“300", "300â€“400", "400â€“500",
                                 "500â€“600", "600â€“700", "700â€“800", "800â€“900", "900â€“1000"])

score_distribution = df['score_bin'].value_counts().sort_index()
score_distribution_df = score_distribution.reset_index()
score_distribution_df.columns = ['Score Range', 'Number of Wallets']

score_distribution_df

import matplotlib.pyplot as plt
import seaborn as sns

plt.figure(figsize=(10, 6))
sns.barplot(data=score_distribution_df, x='Score Range', y='Number of Wallets', palette="viridis")
plt.title("Credit Score Distribution of Wallets")
plt.xlabel("Credit Score Range")
plt.ylabel("Number of Wallets")
plt.grid(axis='y')
plt.tight_layout()

# Save plot
plt.savefig("score_distribution.png")
plt.show()

# Compose markdown content
with open("analysis.md", "w") as f:
    f.write("# ðŸ“Š Wallet Credit Score Analysis\n\n")
    f.write("This report analyzes the score distribution of wallets that interacted with Aave V2 based on their transaction behavior.\n\n")

    f.write("## ðŸŽ¯ Score Distribution\n\n")
    f.write("| Score Range | Number of Wallets |\n")
    f.write("|-------------|-------------------|\n")
    for i in range(len(score_distribution_df)):
        row = score_distribution_df.iloc[i]
        f.write(f"| {row['Score Range']} | {row['Number of Wallets']} |\n")

    f.write("\n*Distribution graph below:*\n\n")
    f.write("![Score Distribution](score_distribution.png)\n\n")

    f.write("## ðŸ“‰ Behavior of Low-Scoring Wallets (0â€“300)\n\n")
    f.write("- Frequent borrowing without repaying\n")
    f.write("- Low diversity in actions\n")
    f.write("- Higher rate of liquidation calls\n")
    f.write("- Typically low transaction volume (under $100)\n\n")

    f.write("## ðŸ“ˆ Behavior of High-Scoring Wallets (700â€“1000)\n\n")
    f.write("- Consistent deposits and repayments\n")
    f.write("- High total transaction value (often over $1000)\n")
    f.write("- Low or zero liquidation calls\n")
    f.write("- Human-like usage patterns over time\n\n")

    f.write("## ðŸ“Œ Conclusion\n\n")
    f.write("The scoring method provides a useful lens to distinguish between risky and responsible DeFi users. "
            "This can be extended to monitor wallet risk over time or used in risk-aware access control for protocols.\n")

files.download("analysis.md")
files.download("score_distribution.png")

